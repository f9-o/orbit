// Package nginx generates NGINX reverse proxy configurations from Orbit service specs.
package nginx

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"text/template"

	v1 "github.com/f9-o/orbit/api/v1"
	"github.com/f9-o/orbit/internal/core/logger"
)

// domainSafe validates a domain is safe to embed in an NGINX config.
var domainSafe = regexp.MustCompile(`^[a-zA-Z0-9.\-]+$`)

// serverBlockTemplate is the NGINX server block template for a proxied service.
const serverBlockTemplate = `
# Generated by Orbit â€” do not edit manually
server {
    listen {{ .Port }};
    server_name {{ .Domain }};

    {{ if .SSL }}
    listen 443 ssl;
    ssl_certificate     {{ .CertPath }};
    ssl_certificate_key {{ .KeyPath }};
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    {{ end }}

    location / {
        proxy_pass         http://127.0.0.1:{{ .BackendPort }};
        proxy_http_version 1.1;
        proxy_set_header   Host              $host;
        proxy_set_header   X-Real-IP         $remote_addr;
        proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto $scheme;
        proxy_set_header   Upgrade           $http_upgrade;
        proxy_set_header   Connection        "upgrade";
        proxy_read_timeout 86400;
    }
}
`

// Generator writes NGINX server block configs and triggers a reload.
type Generator struct {
	configDir string // directory for generated .conf files
	log       *logger.Logger
}

// NewGenerator creates a Generator that writes configs to configDir.
func NewGenerator(configDir string, log *logger.Logger) *Generator {
	return &Generator{configDir: configDir, log: log}
}

// templateData carries values into the server block template.
type templateData struct {
	Domain      string
	Port        int
	SSL         bool
	CertPath    string
	KeyPath     string
	BackendPort int
}

// GenerateAll writes one .conf file per service that has a proxy spec configured.
func (g *Generator) GenerateAll(services []v1.ServiceSpec, certDir string) error {
	if err := os.MkdirAll(g.configDir, 0755); err != nil {
		return fmt.Errorf("create config dir: %w", err)
	}

	tmpl, err := template.New("server").Parse(serverBlockTemplate)
	if err != nil {
		return fmt.Errorf("parse template: %w", err)
	}

	for _, svc := range services {
		if svc.Proxy == nil {
			continue
		}
		if err := g.writeOne(tmpl, svc, certDir); err != nil {
			g.log.Warn("proxy config gen failed", "service", svc.Name, "err", err)
		}
	}
	return nil
}

func (g *Generator) writeOne(tmpl *template.Template, svc v1.ServiceSpec, certDir string) error {
	px := svc.Proxy

	if !domainSafe.MatchString(px.Domain) {
		return fmt.Errorf("unsafe domain %q rejected", px.Domain)
	}

	port := 80
	if px.Port != 0 {
		port = px.Port
	}
	backendPort := px.Backend
	if backendPort == 0 {
		backendPort = 8080
	}

	data := templateData{
		Domain:      px.Domain,
		Port:        port,
		SSL:         px.SSL,
		BackendPort: backendPort,
	}

	if px.SSL {
		data.CertPath = filepath.Join(certDir, px.Domain+".crt")
		data.KeyPath = filepath.Join(certDir, px.Domain+".key")
	}

	outPath := filepath.Join(g.configDir, "orbit_"+svc.Name+".conf")
	f, err := os.Create(outPath)
	if err != nil {
		return fmt.Errorf("create %q: %w", outPath, err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("template execute: %w", err)
	}

	g.log.Info("proxy config written", "service", svc.Name, "path", outPath)
	return nil
}

// Reload sends a graceful reload signal to NGINX.
func (g *Generator) Reload() error {
	cmd := exec.Command("nginx", "-s", "reload") //nolint:gosec
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("nginx reload: %w (output: %s)", err, string(out))
	}
	g.log.Info("nginx reloaded")
	return nil
}
